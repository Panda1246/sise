#+TITLE: Sztuczna inteligencja i systemy ekspertowe
#+SUBTITLE: Zadanie pierwsze: Piętnastka

#+AUTHOR: Piotr Polakowski (247768), Jakub Samek (247781), Filip Kobierski (242336)
#+DATE: 2023.05.13

* Tło
/Piętnastka/, znana również pod angielską nazwą /15 Puzzle/, jest układanką składającą się z ramki i osadzonych w niej 15 elementów.
Elementy te można przesuwać, ponieważ w ramce pozostaje wolne pole o wielkości odpowiadającej jednemu elementowi (zatem cała ramka ma wymiar 4x4).
Łamigłówka polega na takim przesuwaniu elementów układanki, aby z pewnego losowego układu początkowego.

Gra ta zapewne jest dobrze znana osobom które używały w dzeciństwie Windows Vista, gdzie 15puzzle było jedną z gier-widżetów.

#+CAPTION: Przykładowe ułożenie 15puzzle
|    |  1 |  2 |  7 |
|  8 |  9 | 12 | 10 |
| 13 |  3 |  6 |  4 |
| 15 | 14 | 11 |  5 |

#+CAPTION: Cel 15puzzle
|  1 |  2 |  3 |  4 |
|  5 |  6 |  7 |  8 |
|  9 | 10 | 11 | 12 |
| 13 | 14 | 15 |    |

* Cel zadania
Zadanie składa się z dwóch części: programistycznej i badawczej.
Część programistyczna stanowi napisanie programu, który będzie rozwiązywał powyższą łamigłówkę przy użyciu różnych metod przeszukiwania przestrzeni stanów stategii:
+ /wszerz/ (breadth-first search);
+ /w głąb/ (depth-first search);
+ /najpierw najlepszy/: A*, z następującymi heurystykami:
  - metryką Hamminga;
  - metryką Manhattan.

Cel części badawczej stanowi przebadanie, jak powyższe metody przeszukiwania przestrzeni stanów zachowują się w przypadku tego problemu.
** Część programistyczna
*** Wymagania funkcjonalne
Program ma za zadanie generować rozwiązanie powyższej łamigłówki, czyli wyznaczać taki ciąg ruchów odpowiadających przesunięciom wolnego pola, które przeprowadzą układankę z zadanego układu początkowego do układu wzorcowego. Wyznaczony ciąg ruchów reprezentowany będzie za pomocą ciągu liter pochodzących z czteroelementowego zbioru, oznaczających poszczególne przesunięcia zgodnie z poniższą tabelą:

| Przesunięcie    | Litera |
|-----------------+--------|
| w lewo (left)   | L      |
| w prawo (right) | R      |
| w górę (up)     | U      |
| w dół (down)    | D      |

Ponadto program ma generować dodatkowe informacje dotyczące przeprowadzonego procesu obliczeniowego, obejmujące:
- długość znalezionego rozwiązania;
- liczbę stanów odwiedzonych;
- liczbę stanów przetworzonych;
- maksymalną osiągniętą głębokość rekursji;
- czas trwania procesu obliczeniowego.

Każda z metod przeszukiwania przestrzeni stanów wymaga podania dodatkowego parametru.
W przypadku strategii /wszerz/ i strategii /w głąb/ jest to porządek przeszukiwania sąsiedztwa bieżącego stanu, który określony będzie za pomocą ciągu stanowiącego permutację czterech liter zamieszczonych w tabeli powyżej. Natomiast w przypadku strategii A* jest to używana heurystyka.

Dodatkowo w przypadku strategii /w głąb/ należy ustalić maksymalną dozwoloną głębokość rekursji, która nie może być mniejsza niż 20 (wartość tę można wpisać na sztywno do programu).
W sytuacji, gdy program osiągnie taką głębokość nie znalazłszy rozwiązania, powinien wykonać nawrót.

Program będzie pobierać zadany układ początkowy układanki z pliku tekstowego o formacie opisanym poniżej (Plik z układem początkowym).
Znalezione rozwiązanie program będzie zapisywać w innym pliku tekstowym o formacie opisanym poniżej (Plik z rozwiązaniem).
Dodatkowe informacje dotyczące przeprowadzonego procesu obliczeniowego program również będzie zapisywać w osobnym pliku tekstowym o formacie opisanym poniżej (Plik z dodatkowymi informacjami).

Do programu będą przekazywane następujące argumenty wywołania:

1. akronim określający wybraną strategię:
   - =bfs= -- /wszerz/ (breadth-first search)
   - =dfs= -- /w głąb/ (depth-first search)
   - =astr= -- A* (A-star)
2. dodatkowy parametr wybranej strategii:
   - =[LRUD]=
   - =hamm= bądź =manh= dla heurystyk Hamminga i Manhattan
3. nazwa pliku tekstowego z zadanym układem początkowym układanki;
4. nazwa pliku tekstowego, w którym ma zostać zapisane rozwiązanie;
5. nazwa pliku tekstowego, w którym mają zostać zapisane dodatkowe informacje dotyczące przeprowadzonego procesu obliczeniowego.

Przykładowe wywołania programu:
- strategia /wszerz/ z porządkiem przeszukiwania sąsiedztwa prawo-dół-góra-lewo:
  : program bfs  RDUL 4x4_01_0001.txt 4x4_01_0001_bfs_rdul_sol.txt 4x4_01_0001_bfs_rdul_stats.txt
- strategia /w głąb/ z porządkiem przeszukiwania sąsiedztwa lewo-góra-dół-prawo:
  : program dfs  LUDR 4x4_01_0001.txt 4x4_01_0001_dfs_ludr_sol.txt 4x4_01_0001_dfs_ludr_stats.txt
- strategia A* z heurystyką w postaci metryki Manhattan:
  : program astr manh 4x4_01_0001.txt 4x4_01_0001_astr_manh_sol.txt 4x4_01_0001_astr_manh_stats.txt

Wprawdzie program będzie służył do przebadania zachowania poszczególnych metod przeszukiwania przestrzeni stanów w przypadku klasycznej /Piętnastki/, musi on być jednak napisany w sposób uniwersalny, to znaczy taki, który umożliwi generowanie rozwiązań także dla ramek o innych niż standardowe rozmiarach, w tym ramek niekwadratowych.
*** Plik z układem początkowym
Jest to plik tekstowy, w którym liczba linii zależy od rozmiaru ramki.
Pierwsza linia zawiera dwie liczby całkowite w oraz k, oddzielone od siebie spacją, które określają odpowiednio pionowy (liczbę wierszy) i poziomy (liczbę kolumn) rozmiar ramki.
Każda z pozostałych w linii zawiera k oddzielonych spacjami liczb całkowitych, które opisują położenie poszczególnych elementów układanki, przy czym wartość 0 oznacza wolne pole.
*** Plik z rozwiązaniem
Jest to plik tekstowy standardowo składający się z 2 linii. Pierwsza z nich zawiera liczbę całkowitą n, określającą długość znalezionego rozwiązania (czyli długość ciągu ruchów odpowiadających przesunięciom wolnego pola, które przeprowadzą układankę z zadanego układu początkowego do układu wzorcowego). Natomiast w drugiej linii znajduje się ciąg n liter odpowiadających poszczególnym ruchom wolnego pola w ramach znalezionego rozwiązania, zgodnie z reprezentacją przedstawioną w tabeli zamieszczonej wyżej. Jeżeli dla zadanego układu początkowego program nie znalazł rozwiązania, wówczas plik składa się tylko z 1 linii, która zawiera liczbę -1.
*** Plik z dodatkowymi informacjami
Jest to plik tekstowy składający się z 5 linii, z których każda zawiera jedną liczbę oznaczającą odpowiednio:
1. (liczba całkowita): długość znalezionego rozwiązania - o takiej samej wartości jak w pliku z rozwiązaniem (przy czym gdy program nie znalazł rozwiązania, wartość ta to -1);
2. (liczba całkowita): liczbę stanów odwiedzonych;
3. (liczba całkowita): liczbę stanów przetworzonych;
4. (liczba całkowita): maksymalną osiągniętą głębokość rekursji;
5. (liczba rzeczywista z dokładnością do 3 miejsc po przecinku): czas trwania procesu obliczeniowego w milisekundach.

** Część badawcza
Należy przebadać wszystkie układy początkowe układanki w odległościach 1-7 od układu wzorcowego.
# w sumie 413 układów
W przypadku strategii /wszerz/ i strategii /w głąb/ użyć 8 następujących porządków przeszukiwania sąsiedztwa:
1. RDUL
2. RDLU
3. DRUL
4. DRLU
5. LUDR
6. LURD
7. ULDR
8. ULRD

W przypadku strategii A* użyć obu heurystyk.

Korzystając z informacji zawartych w plikach z dodatkowymi informacjami dotyczącymi przeprowadzonego procesu obliczeniowego porównać skuteczność poszczególnych metod przeszukiwania przestrzeni stanów.
Dane dotyczące poszczególnych aspektów rozważanych przy porównaniach zobrazować na wykresach (prezentacja danych w inny sposób skutkować będzie obniżeniem oceny).
Wyciągnąć wnioski na podstawie zaprezentowanych wyników.

# Ostatnia modyfikacja: sobota, 29 lutego 2020, 12:40


* Sprawozdanie
** Część programistyczna
*** Algorytm BFS
Algorytm BFS działa w taki sposób, że przeszukuje wszystkie możliwe stany idąc wszerz od węzła głównego – przeszukuje zatem wszystkie dostępne węzły na danej głębokości. Przekładając to na praktyczną implementację w „piętnastce” węzłem początkowym jest stan układanki, którą należy rozwiązać, a końcowym – układanka rozwiązana – ze wszystkimi elementami na odpowiedniej kolejności. Podczas każdej iteracji algorytmu sprawdza on dostępne możliwe ruchy, i jeżeli dane przesunięcie elementu zerowego da w rezultacie układ, który nie był do tej pory dla algorytmu znany, to staje się on kolejnym węzłem i będzie bazą do generowania możliwych przesunięć w kolejnych iteracjach. Po wygenerowaniu możliwych stanów dla danego węzła algrytm przystępuje do generowania możliwych stanów dla kolejnego węzła na tej samej głębokości, o ile jest on dostępny. Stosowana w tym przypadku jest struktura FIFO(kolejka). Algorytm kończy się w momencie, w którym napotka na stan, który odpowiada rozwiązanej układance.
*** Algorytm DFS
Algorytm DFS natomiast wyszukuje „w głąb”, czyli zamiast eksplorować wszystkie możliwe stany układanek na jednej głębokości zajmuje się jedną konkretną gałęzią – gdy znajdzie możliwy ruch w danej układance to wykonuje go, i dla układanki świeżo co zmienionej eksploruje kolejne możliwe przesunięcia. Algorytm będzie szedł „w głąb” tak długo, aż nie wyczerpie liczby możliwych stanów(co w przypadku układanki 4x4 zajęłoby bardzo dużo czasu) bądź gdy osiągnie zadaną liczbę stanów określoną manualnie w algorytmie przez programistę. Niezależnie od napotkanej przyczyny niemożności wykonania kolejnych przesunięć gdy taka sytuacja nastąpi, to algorytm cofa się do poprzedniego węzła i eksploruje kolejny możliwy stan tak samo jak w poprzednim przypadku. Algorytm DFS jest bardzo łatwy w implementacji za pomocą rekursji, natomiast można go też z powodzeniem zaimplementować iteracyjnie używając do tego celu stosu(LIFO). Algorytm kończy się, gdy znaleziona układanka będzie w takim stanie, jak układanka rozwiązana.

*** Algorytm A*
Algorytm A* jest w swoim działaniu podobny do algorytmu BFS, jednakże ma jedną sporą różnicę – nie wyznacza on „na ślepo” kolejnych możliwych sąsiadów – w naszym przypadku rozwiązań układanki, tylko posługuje się określoną metryką pozwalającą wyznaczyć najbardziej optymalny stan. W przypadku zaimplementowanego algorytmu zostały zastosowane dwie metryki:
    • Hamminga – bardzo prosta, jest to liczba pól układanki, które nie są na swoich miejscach
    • Manhattan – jest to suma odległości manhattan każdego z pól układanki od swojego miejsca docelowego
Generalnie wzór opisujący obliczanie metryki dla kolejnego stanu wygląda następująco:
\begin{equation}
f(n) = h(n) + g(n)
\end{equation}
, gdzie
- $f(n)$ -- aktualny priotytet danego węzła(układanki)
- $h(n)$ -- wartość przyjętej metryki(w tym przypadku Hamminga lub Manhattan)
- $g(n)$ -- głębokość aktualnie przetwarzanego węzła

W odróżnieniu od poprzednio opisanych algorytmów A* korzysta z tzw kolejki z priorytetem – jak sama nazwa wskazuje pierwszeństwo w przetwarzaniu ma zawsze węzeł, który posiada najmniejszy w tym wypadku priorytet(mniej = lepiej). Przetwarzanie jest realizowane do momentu, gdy zostanie odnaleziony właściwy układ planszy lub wyczerpią się możliwości ruchów.

*** Język programowania
Początkowo planowaliśmy napisać program w Javie, gdyż jest ona podobnie międzyplatformowa i kompilowana do bajtkodu.
Nawet pomimo jej większej efektywności i mniej surowych reguł składni do wykonania tego zadania wykorzystaliśmy język Python.
Ma on dynamiczne typy i jest interpretowany, czyli powolny, jednak jego kod ma mniej /boilerplate/ -- można wyrazić swoje myśli w kodzie mniejszą ilością znaków.
*** 
** Część badawcza
Instrukcja narzuciła stworzenie dwóch plików -- jednego z rozwiązaniem a drugiego z dodatkowymi informacjami.
My stwierdziliśmy, że prościej jest przetwarzać dane do badań jeśli są one zagregowane w jednym pliku i stworzyliśmy skrypt powłoki [TODO: daj link], który agreguje nam dane.

** Wykresy
#+begin_quote
Jeden obraz jest w stanie powiedzieć więcej niż tysiąc słów.
#+end_quote
